#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri May  2 21:00:45 2025

@author: annabel_large


About:
======
5th test for substitution models

Check the log-probability of some fake alignments by hand loops, and with
  my functions

"""
import jax
from jax import numpy as jnp
import numpy as np

import numpy.testing as npt
import unittest

from unit_tests.req_files.data_processing import (str_aligns_to_tensor,
                                                  summarize_alignment)
from models.simple_site_class_predict.emission_models import (_rate_matrix_from_exch_equl,
                                                              get_cond_logprob_emit_at_match_per_class,
                                                              get_joint_logprob_emit_at_match_per_class)
from models.simple_site_class_predict.PairHMM_indp_sites import (_score_alignment)


THRESHOLD = 1e-6


class TestAlignmentLoglikeGTR(unittest.TestCase):
    """
    SUBSTITUTION PROCESS SCORING TEST 5
    
    B: batch (samples)
    L: length (number of alignment columns)
    C: hidden site classes
    T: branch lengths (time)
    A: alphabet
    
    About
    ------
    Check the log-probability of some fake alignments by hand loops, and with
      my functions; using scoring matrices generated by validated functions
    
    """
    def test_score_alignment(self):
        ### generate fake alignments
        fake_aligns = [ ('AC-A','D-ED'),
                        ('D-ED','AC-A'),
                        ('ECDAD','-C-A-'),
                        ('-C-A-','ECDAD') ]
        
        fake_aligns =  str_aligns_to_tensor(fake_aligns) #(B, L, 3)
            
        vmapped_summarize_alignment = jax.vmap(summarize_alignment, 
                                               in_axes=0, 
                                               out_axes=0)
        counts =  vmapped_summarize_alignment( fake_aligns )
        match_counts = counts['match_counts'][:, :4, :4] #(B, A, A)
        
        
        ### params to work with
        exchangeabilities = np.array([[0, 1, 2, 3],
                                      [1, 0, 4, 5],
                                      [2, 4, 0, 6],
                                      [3, 5, 6, 0]]) #(A,A)
        
        equilibrium_distributions = np.array([0.1, 0.2, 0.3, 0.4])[None,:] #(C,A)
        
        Q = _rate_matrix_from_exch_equl(exchangeabilities,
                                        equilibrium_distributions,
                                        norm=True) #(C,A,A)
        
        t_array = np.array( [0.3, 1, 1.5] ) #(T,)
        
        B = fake_aligns.shape[0]
        L = fake_aligns.shape[1]
        C = Q.shape[0]
        T = t_array.shape[0]
        A = Q.shape[1]
        
        log_cond,_ = get_cond_logprob_emit_at_match_per_class(t_array = t_array,
                                                              scaled_rate_mat_per_class = Q) #(T,C,A,A)
        del Q, exchangeabilities
        
        log_joint = get_joint_logprob_emit_at_match_per_class(cond_logprob_emit_at_match_per_class = log_cond,
                                                              log_equl_dist_per_class = np.log(equilibrium_distributions))  #(T,C,A,A)
        
        
        ### calculate by loops
        true_scores = np.zeros( (T,B) ) #(T,B)
        for t in range(T):
            for b in range(B):
                for l in range(L):
                    anc_tok, desc_tok, alignment_tok = fake_aligns[b, l, :]
                    if alignment_tok == 1:
                        logprob_of_this_column = log_joint[t,0,anc_tok-3, desc_tok-3]
                        true_scores[t,b] += logprob_of_this_column
        
        
        ### calculate with my function
        pred_scores = _score_alignment(subCounts = match_counts,
                                       insCounts = np.zeros((B,A)),
                                       delCounts = np.zeros((B,A)),
                                       transCounts = np.zeros((B, 4, 4)),
                                       logprob_emit_at_match = log_joint[:,0,...],
                                       logprob_emit_at_indel = np.zeros((A)),
                                       transit_mat = np.zeros((T,4,4)))  #(T,B)
        
        
        npt.assert_allclose(true_scores, pred_scores, atol=THRESHOLD)

if __name__ == '__main__':
    unittest.main()
