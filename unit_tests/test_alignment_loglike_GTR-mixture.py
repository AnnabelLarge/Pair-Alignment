#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May  5 09:47:56 2025

@author: annabel_large


ABOUT:
======
test the independent site class code by scoring manually with a loop

"""
import jax
import numpy as np

import numpy.testing as npt
import unittest

from unit_tests.req_files.data_processing import (str_aligns_to_tensor,
                                                  summarize_alignment)
from models.simple_site_class_predict.emission_models import (_rate_matrix_from_exch_equl,
                                                              get_cond_logprob_emit_at_match_per_class,
                                                              get_joint_logprob_emit_at_match_per_class)
from models.simple_site_class_predict.PairHMM_indp_sites import (_score_alignment,
                                                                 _lse_over_match_logprobs_per_class)




THRESHOLD = 1e-6


class TestAlignmentLoglikeGTRMixture(unittest.TestCase):
    """
    SUBSTITUTION PROCESS SCORING TEST 6
    
    B: batch (samples)
    L: length (number of alignment columns)
    C: hidden site classes
    T: branch lengths (time)
    A: alphabet
    
    About
    ------
    Check the log-probability of some fake alignments by hand loops, and with
      my functions; using scoring matrices generated by validated functions;
      under assumption of independent site class mixtures
    
    """
    def test_score_alignment(self):
        ### generate fake alignments
        fake_aligns = [ ('AC-A','D-ED'),
                        ('D-ED','AC-A'),
                        ('ECDAD','-C-A-'),
                        ('-C-A-','ECDAD') ]
        
        fake_aligns =  str_aligns_to_tensor(fake_aligns) #(B,L,3)
            
        vmapped_summarize_alignment = jax.vmap(summarize_alignment, 
                                               in_axes=0, 
                                               out_axes=0)
        counts =  vmapped_summarize_alignment( fake_aligns )
        match_counts = counts['match_counts'][:, :4, :4] #(B,A,A)
                
        
        ### params to work with
        exchangeabilities = np.array([[0, 1, 2, 3],
                                      [1, 0, 4, 5],
                                      [2, 4, 0, 6],
                                      [3, 5, 6, 0]]) #(A,A)
        
        equilibrium_distributions_1 = np.array([0.1, 0.2, 0.3, 0.4])
        equilibrium_distributions_2 = np.array([0.4, 0.3, 0.2, 0.1])
        equilibrium_distributions = np.stack([equilibrium_distributions_1,
                                              equilibrium_distributions_2]) #(C,A)
        del equilibrium_distributions_1, equilibrium_distributions_2
        
        Q = _rate_matrix_from_exch_equl(exchangeabilities,
                                        equilibrium_distributions,
                                        norm=True) #(C,A,A)
        
        class_probs = np.array([0.4, 0.6]) #(C)
        log_class_probs = np.log(class_probs) #(C)
        t_array = np.array( [0.3, 1.0, 0.2] ) #(T)
        
        
        B = fake_aligns.shape[0]
        L = fake_aligns.shape[1]
        C = Q.shape[0]
        T = t_array.shape[0]
        A = Q.shape[1]
        
        log_cond,_ = get_cond_logprob_emit_at_match_per_class(t_array = t_array,
                                                              scaled_rate_mat_per_class = Q) #(T,C,A,A)
        log_joint = get_joint_logprob_emit_at_match_per_class(cond_logprob_emit_at_match_per_class = log_cond,
                                                              log_equl_dist_per_class = np.log(equilibrium_distributions)) #(T,C,A,A)
        del Q, log_cond
        
        ### manually score each site
        true_scores = np.zeros( (T,B) ) #(T,B)
        for t in range(T):
            for b in range(B):
                for l in range(L):
                    anc_tok, desc_tok, alignment_tok = fake_aligns[b, l, :]
                    if alignment_tok == 1:
                        prob_of_this_column = 0
                        for c in range(C):
                            mixture_joint_matrix = np.exp(log_joint[t,c,...])
                            mixture_prob = class_probs[c]
                            
                            # P(c) P(x,y|c,t)
                            prob_of_this_column += (mixture_prob *
                                                   mixture_joint_matrix[anc_tok-3, desc_tok-3] )
                        
                        true_scores[t,b] += np.log(prob_of_this_column)
        
        
        
        ### calculate with my function
        pred_scoring_matrix = _lse_over_match_logprobs_per_class(log_class_probs = log_class_probs,
                                               joint_logprob_emit_at_match_per_class = log_joint) #(T,A,A)
        pred_scores = _score_alignment(subCounts = match_counts,
                                       insCounts = np.zeros((B,A)),
                                       delCounts = np.zeros((B,A)),
                                       transCounts = np.zeros((B, 4, 4)),
                                       logprob_emit_at_match = pred_scoring_matrix,
                                       logprob_emit_at_indel = np.zeros((A)),
                                       transit_mat = np.zeros((T,4,4))) #(T,B)
        
        npt.assert_allclose(true_scores, pred_scores, atol=THRESHOLD)

if __name__ == '__main__':
    unittest.main()
